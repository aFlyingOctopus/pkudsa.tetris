# Tetris——方块大战用户文档

理论上, 本文档和规则文档可以作为开发对战AI所需文档的最小集合. 但调试复盘工具链文档待给出/合并.

用户(或用户AI)根据语境, 可能指开发比赛程序的人类或用于对战, 能根据盘面给出决策, 并最大化胜利可能的程序

平台指驱动对战初始化、进行和结束, 给出盘面信息和运行环境, 并调用用户AI的决策方法, 判断胜负的程序.

未定义行为指该行为中平台的行为不受规范, 可能是对战中的任何负面后果. 若未定义行为被其它文档定义, 则遵从该定义文档.

## 用户规范

本章节对用户AI的行为进行规范.

### 引言

Tetris AI 是实现了根据现有盘面和当前块输出合法的放置位置的命名为`Player`的类.

需要实现的成员方法具有以下原型

```Python
def __init__(self: Player, isFirst: bool) -> None:
    pass
def output(self: Player, data：Data) -> Tuple[int, int, int]:
    pass
```

平台将会在适当时机调用这些方法.

### 初始化

当平台需要生成一个新的用户AI实例时`__init__`方法被调用. 平台不保证己方初始化与对手初始化的调用顺序, 也不保证新的一场比赛开始时旧的AI实例被销毁.

1. 先后手

    isFirst 是一个布尔参量,其真假表示本局中此 AI 是否是先手

### 输出

1. 基本流程

    游戏开始后,每个回合先后手顺序执行。

    1. 先手给出针对现有盘面和当前块的放置位置
    2. 平台结算先后玩家得分,更新盘面
    3. 先手给出针对现有盘面和当前块的放置位置
    4. 平台结算先后玩家得分,更新盘面

    重复以上回合直到游戏结束。在每次回合中,先手方和后手方的`output`函数会在该方需要给出其决策时被调用, 参数为一个`Data`类的实例:

    在轮到某方进行操作时,用户应当返回`Tuple[y, x, direction]`表示当前块的放置位置和放置方向.

    1. `y`: 放置位置的棋盘行号, 从上到下为0到14的`int`
    2. `x`: 要下棋位置的棋盘的列号, 从左到右为0到9的`int`
    3. `direction`: 方向, 取值`0,1,2,3`, 对应规则见规则文档

2. Data类

    Data类是一个包含了当前棋盘盘面和当前块等必要信息的数据包,其内置方法见平台规范的对应部分.

### 注意事项

1. 结束情况

    不需要考虑游戏结束的情况,假若无法继续游戏会自动结束.

2. 安全要求

    平台向用户传入Data类实例中的数据为平台数据的实时拷贝, 用户对传入数据进行任何更改都不会对平台造成影响.同时,平台并不要求玩家在操作结束时将数据还原.(例如,如果有玩家尝试直接更改传入的分数,平台并不阻止这种行为,但这种行为并不会影响平台正常运作，亦不会对平台中已有数据造成影响.)己方游戏进行有最大累计时间限制,运行超时会直接判负,请注意分配运算量.

3. 引用外部模块

    对战平台采用白名单机制. 现允许使用的第三方模块如下
    + math
    + random
    + copy
    + numpy
    + time
    + collections
    + itertools
    + functools
    + heapq
    + operator
    如果有合理需求, 可以向助教或技术组申请引入新的模块.

    此外, 为了阻止绕过代码检查, 以下方法被禁用
    + exec
    + eval
    + compile

## 平台规范

本章节对用户可见的平台行为进行规范(其实本章节没啥说的)

### Data类实例

对战中某时刻的棋盘状态和当前块等必要信息由经参数`data`传给用户AI实现的`output`函数的一个`Data`对象给出. 若调用或使用了棋盘除给出接口外的方法或属性, 后果自负.

该对象具有以下方法

   1. `__init__(self: Data) -> None` 初始化

   2. `getValidActCpp(self: Data) -> List[Tuple[int, int, int]]` 获取针对当前块和当前棋盘的所有合法放置位置

       返回:由该方本回合所有合法操作构成的list类型变量
       (你一定好奇函数名称最后为什么会有一个“Cpp”,因为该方法并非由Python语言实现,且我们并没有在平台上公布实现此方法的源代码,如果你想了解该方法的实现原理可以查看下一个方法:`getValidAct`)

   3. `getValidAct(self: Data) -> List[Tuple[int, int, int]]` 此方法可以实现与上一个方法同样的效果,但是耗时很长！！！极度不推荐使用！！！

       再次声明:此方法唯一的存在意义是帮助大家了解此方法的实现原理,但耗时是前一个方法的1000倍左右！！！

   4. `getAllValidActCpp(self: Data, type: int, board: List[List[]]) -> List[Tuple[int, int, int]]` 获取针对任意块和任意棋盘的所有合法放置位置

       参数:type块的种类, board任意棋盘

       返回:由输入块和输入棋盘决定的所有合法操作构成的list类型变量
       (“Cpp”的存在同上)

   5. `getAllValidAct(self: Data, type: int, board: List[List[]]) -> List[Tuple[int, int, int]]` 此方法可以实现与上一个方法同样的效果,但是耗时很长！！！极度不推荐使用！！！

       再次声明:此方法唯一的存在意义是帮助大家了解此方法的实现原理,但耗时是前一个方法的1000倍左右！！！

   6. `getCurrentRound(self: Data) -> int` 获取当前回合数

       返回:当前回合数

   7. `getBoard(self: Data) -> List[List[int]]` 获取当前棋盘(后手玩家会获得翻转后棋盘)

       返回:由0到7组成的二维数组(即list内部嵌套list的结构),0为空格,非0代表此格已被方块占用

       返回例子如下:

       ```Python
       [
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,2,0,0,0,0,0,0,0,0],
           [0,2,0,0,0,0,0,0,0,0],
           [1,2,0,0,3,0,2,0,7,0],
           [0,0,1,0,0,0,0,0,0,0],
           [0,0,0,1,0,0,0,0,0,0],
           [0,4,0,0,5,5,6,0,7,0],
           [0,0,0,0,0,0,4,0,0,0],
           [0,2,0,0,0,0,0,5,0,0],
           [0,0,1,0,0,0,0,0,6,0],
           [0,3,2,0,5,6,0,0,0,0],
           [0,0,0,0,0,6,0,0,0,0],
           [0,0,0,0,5,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
           [0,0,0,0,0,0,0,0,0,0],
       ]
       ```

   8. `getBlock(self: Data) -> int` 获取当前块

       返回:1到7的int类型变量,依次指代I,J,L,O,S,T,Z型方块

   9. `getBlockList(self: Data) -> List[int]` 获取从下一块(即对手即将操作的方块)开始的剩余块列表

       返回:由剩余块(以1到7的int类型变量表示)

   10. `viewMyPoint(self: Data) -> int` 查看自己当前的分数

   11. `viewOpponentPoint(self: Data) -> int` 查看对手当前的分数

   12. `getCombo(self: Data) -> int` 返回当前的战斗区连击次数

   13. `getTimeLeft(self: Data) -> float` 查看自己的剩余决策时间

   14. `putBlock(self: Data, type: int, act: Tuple[int, int, int], board: List[List[int]]) -> List[List[int]]` 向某一棋盘中放置某种方块

       参数:type块的种类, act对块的操作, board被放置的棋盘

       返回:放置方块后的棋盘

   15. `showBlock(self: Data, type: int, act: Tuple[int, int, int]) -> List[Tuple[int, int]]`

       参数:type块的种类, act对块的操作

       返回:由最终在棋盘上占用的四个格子的坐标构成的list类型变量

## 编辑历史

2022.3.31 创建此文档